IFJ25 - Semantic Analysis Rules
==================================

1. Symbol and Scope Rules
-------------------------

Variable declarations and usage
- Every variable must be declared before it is used. -> Error 3
- A variable can only be declared once per scope. -> Error 4
- A variable can shadow a variable from an outer scope (if allowed).
- Variable names are case-sensitive.
- Variable names follow standard naming rules (checked by lexer).

Scope handling
- Each function introduces its own local scope.
- Blocks (if / while) can have their own sub-scopes.
- At the end of the function, local variables go out of scope.

2. Function Rules
-----------------

Function definitions and declarations
- Each function must be defined exactly once. -> Error 4
- Function names are global.
- Function parameters are local to the function.
- Duplicate parameter names -> Error 4.

Function calls
- Every called function must exist. -> Error 3
- Number of arguments must match parameter count. -> Error 5
- Argument types must be compatible if known statically. -> Error 6
- Calling an undefined function -> Error 3

Special function rules
- Built-in functions (inputs, inputi, inputf, print, len, substr, ord, chr)
  are always defined in global symbol table.
- Argument counts and types must match their specification.

3. Expression and Type Rules
----------------------------

Literals
- Supported literals: integer, float, string, null.
- Each literal has a static type.

Binary operations
- +, -, *, / valid only for numeric operands.
- + may also concatenate strings.
- Comparison operators: ==, !=, <, <=, >, >= must have compatible operands.
- Logical operators (!, &&, ||) require boolean-convertible operands.
- Incompatible types -> Error 6.
- Division by zero not checked at compile time.

Type conversions
- Implicit conversions allowed at runtime.
- Detect only obvious static mismatches.

Variable assignments
- Variable must exist before assignment. -> Error 3
- Incompatible known types -> Error 6
- Assignment updates variable type if possible.

4. Control Structures
----------------------

If / Else
- Condition must be valid expression.
- Each block may have its own scope.

While
- Condition must be valid expression.
- Same scope rules as if/else.

5. Return Statements and Function Results
-----------------------------------------

- Inside a function, return type should match (if enforced). -> Error 6
- Return outside a function -> Error 10.

6. Built-in Functions
---------------------

Function | Parameters | Return Type | Notes
----------------------------------------------------------
inputs() | none | string or null | read line
inputi() | none | int or null | read integer
inputf() | none | float or null | read float
print(...) | variable count | none | prints values
len(s) | string | int | string length
substr(s, i, j) | string, int, int | string or null | substring
ord(s, i) | string, int | int | ASCII code
chr(i) | int | string | single character

Built-ins are preloaded in the global symbol table.

7. Error Codes
--------------

3 - undefined variable/function
4 - redefinition of variable/function
5 - wrong number of arguments
6 - static type error
10 - other semantic error
99 - internal error

8. Semantic Phase Overview
--------------------------

Steps:
1. Preload built-in functions.
2. Traverse expression tree:
   - Variable declaration -> insert, check duplicates.
   - Variable usage -> lookup existence.
   - Assignment -> check both sides.
   - Function definition -> insert global, check redefinition.
   - Function call -> lookup global, check arity and type.
   - Expression -> infer and verify operand types.
   - Return -> check context.
3. Return first error found or 0 if OK.
